import logging
from typing import Any, Dict, List

from google.genai import types

from bard.ai.config import GeminiConfigManager
from bard.tools.base import BaseTool, ToolContext
from bard.util.logging import clean_dict, prettify_json_for_logging

logger = logging.getLogger("Bard")


class CodeExecutionTool(BaseTool):
    """
    A tool that allows the Gemini model to generate and execute Python code.
    It handles code generation, execution, and the processing of results,
    including capturing stdout, stderr, and generated images.
    """

    tool_emoji = "ðŸ’»"

    def __init__(self, context: ToolContext):
        """
        Initializes the CodeExecutionTool.

        Args:
            context: The ToolContext object providing shared resources.
        """
        super().__init__(context=context)

    def get_function_declarations(self) -> List[types.FunctionDeclaration]:
        """
        Returns the function declarations for the `execute_python_code` function.
        This function is exposed to the Gemini model to allow it to call this tool.
        """
        return [
            types.FunctionDeclaration(
                name="execute_python_code",
                description=(
                    "Purpose: This tool empowers the AI to programmatically address complex challenges, manipulate data, execute algorithms, and produce visual outputs directly within its operational environment. It facilitates advanced problem-solving that benefits from computational execution. Arguments: This function accepts a `code_task` argument, which is a clear and concise description of the Python code to be generated and executed. Results: Upon execution, this tool returns the standard output (stdout) and standard error (stderr) generated by the Python script. Additionally, if the script produces any images (e.g., plots or graphs), these visual outputs are processed and returned to the user. Restrictions/Guidelines: Use this tool for tasks that specifically require computation, in-depth data analysis, logical problem-solving, or the graphical representation of data. Do not use this tool for simple questions that can be answered conversationally, or for tasks that require external web access, as those should be handled by the `InternetTool`."
                ),
                parameters=types.Schema(
                    type=types.Type.OBJECT,
                    properties={
                        "code_task": types.Schema(
                            type=types.Type.STRING,
                            description="A clear and concise description of the Python code to be generated and executed.",
                        )
                    },
                    required=["code_task"],
                ),
            )
        ]

    def _create_code_execution_config(self) -> types.GenerateContentConfig:
        """
        Creates the Gemini generation configuration for an internal code execution call.
        This configuration enables the model to generate and execute code.
        """
        safety_settings = GeminiConfigManager.get_base_safety_settings()
        config = types.GenerateContentConfig(
            system_instruction=types.Content(
                parts=[
                    types.Part(
                        text="Critical directive: generate and execute Python code and provide a verbose summary or the generated image."
                    )
                ],
                role="system",
            ),
            temperature=1.0,
            top_p=0.95,
            max_output_tokens=self.context.config.MAX_OUTPUT_TOKENS,
            safety_settings=safety_settings,
            tools=[types.Tool(code_execution=types.ToolCodeExecution())],
        )
        return config

    def _create_code_execution_internal_prompt(
        self, code_task: str
    ) -> List[types.Content]:
        """
        Creates the internal prompt for the secondary Gemini call that generates Python code.
        This prompt guides the model to produce executable Python code based on the given task.

        Args:
            code_task: A description of the Python code to be generated.
            `google.generative_ai` does not exist. `google.genai` is correct.
        Returns:
            A list of Gemini Content objects forming the prompt.
        """
        prompt_parts = []

        prompt_parts.append(
            types.Part(
                text=f"Please generate and execute Python code to accomplish the following task: {code_task}. Provide a verbose summary of the execution or the generated image."
            )
        )
        prompt = [types.Content(parts=prompt_parts, role="user")]
        return prompt

    async def execute_tool(
        self, function_name: str, args: Dict[str, Any], context: ToolContext
    ) -> types.Part:
        """
        Executes the `execute_python_code` function.
        This involves making a secondary Gemini call to generate and run Python code,
        then processing its output and any generated images.

        Args:
            function_name: The name of the function to execute (expected to be "execute_python_code").
            args: A dictionary containing the `code_task` argument.
            context: The ToolContext object providing shared resources.

        Returns:
            A Gemini types.Part object containing the function response, including
            success status, output, and any generated image details.
        """
        if function_name != "execute_python_code":
            return types.Part(
                function_response=types.FunctionResponse(
                    name=function_name,
                    response={
                        "success": False,
                        "error": f"Unknown function in CodeExecutionTool: {function_name}",
                    },
                )
            )
        gemini_client = context.get("gemini_client")
        if not gemini_client:
            error_msg = "Missing 'gemini_client' from context."
            logger.error(f"CodeExecutionTool: {error_msg}")
            return types.Part(
                function_response=types.FunctionResponse(
                    name=function_name, response={"success": False, "error": error_msg}
                )
            )
        code_task = args.get("code_task")
        if not code_task:
            error_msg = "Missing 'code_task' argument."
            logger.error(f"CodeExecutionTool: {error_msg}")
            return types.Part(
                function_response=types.FunctionResponse(
                    name=function_name, response={"success": False, "error": error_msg}
                )
            )

        code_exec_config = self._create_code_execution_config()

        contents_for_code_exec = self._create_code_execution_internal_prompt(code_task)

        try:
            request_payload = {
                "model": self.context.config.MODEL_ID,
                "contents": [c.model_dump() for c in contents_for_code_exec],
                "config": code_exec_config.model_dump(),
            }
            logger.debug(
                f"Gemini API (code_execution) request:\n{prettify_json_for_logging(clean_dict(request_payload))}"
            )
            response = await gemini_client.aio.models.generate_content(
                model=self.context.config.MODEL_ID,
                contents=contents_for_code_exec,
                config=code_exec_config,
            )
            logger.debug(
                f"Gemini API (code_execution) response:\n{prettify_json_for_logging(clean_dict(response.dict()))}"
            )
            text_output = ""
            image_generated = False
            generated_filename = None
            if response.candidates:
                for candidate in response.candidates:
                    for part in candidate.content.parts:
                        if part.inline_data and part.inline_data.mime_type.startswith(
                            "image/"
                        ):
                            mime_type = part.inline_data.mime_type
                            extension = self.context.mime_detector.get_extension(
                                mime_type
                            )
                            generated_filename = f"plot{extension}"
                            self.context.tool_response_data["image_data"] = (
                                part.inline_data.data
                            )
                            self.context.tool_response_data["image_filename"] = (
                                generated_filename
                            )
                            image_generated = True
                            self.context.is_final_output = True
                            text_output = f"Image generated: {generated_filename}"
                        elif part.code_execution_result:
                            if (
                                not image_generated
                                and part.code_execution_result.output
                            ):
                                text_output += part.code_execution_result.output + "\n"
                        if part.executable_code and part.executable_code.code:
                            code_content = part.executable_code.code
                            self.context.tool_response_data["code_data"] = (
                                code_content.encode("utf-8")
                            )
                            self.context.tool_response_data["code_filename"] = "code.py"
                logger.debug(
                    f"Parsed code execution response. Text output length: {len(text_output)}, Image generated: {image_generated}, Filename: {generated_filename}."
                )
            else:
                feedback = response.prompt_feedback
                feedback_str = str(feedback) if feedback else "No candidates returned."
                logger.error(f"Code execution call failed. Feedback: {feedback_str}.")
                return types.Part(
                    function_response=types.FunctionResponse(
                        name=function_name,
                        response={"success": False, "error": feedback_str},
                    )
                )
            return types.Part(
                function_response=types.FunctionResponse(
                    name=function_name,
                    response={
                        "success": True,
                        "output": text_output.strip(),
                        "image_generated": image_generated,
                        "filename": generated_filename,
                    },
                )
            )
        except Exception as e:
            error_msg = str(e)
            logger.error(
                f"Unhandled exception during CodeExecutionTool API call: {error_msg}.",
                exc_info=True,
            )
            return types.Part(
                function_response=types.FunctionResponse(
                    name=function_name,
                    response={
                        "success": False,
                        "error": f"An exception occurred: {error_msg}",
                    },
                )
            )
